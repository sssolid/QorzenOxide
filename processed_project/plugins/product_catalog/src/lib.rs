use std::collections::HashMap;use std::sync::Arc;use async_trait::async_trait;use serde::{Deserialize,Serialize};use tokio::sync::RwLock;use chrono::{DateTime,Utc};use qorzen_oxide::{plugin::*,plugin::search::{SearchProvider,SearchResult,ProviderHealth,SearchSuggestion,SearchFacet,FacetValue},auth::{Permission,PermissionScope},error::{Error,Result},event::Event,utils::Time,config::SettingsSchema,};#[derive(Debug,Clone,Serialize,Deserialize)]pub struct Product{pub id:String,pub name:String,pub description:String,pub category:String,pub price:f64,pub currency:String,pub stock_quantity:i32,pub sku:String,pub barcode:Option<String>,pub images:Vec<String>,pub attributes:HashMap<String,serde_json::Value>,pub created_at:DateTime<Utc>,pub updated_at:DateTime<Utc>,pub is_active:bool,}#[derive(Debug,Clone,Serialize,Deserialize)]pub struct PluginConfig{pub api_endpoint:Option<String>,pub database_url:Option<String>,pub use_api:bool,pub cache_duration_secs:u64,pub search_enabled:bool,pub max_results:usize,}impl Default for PluginConfig{fn default()->Self{Self{api_endpoint:Some("https://api.example.com/products".to_string()),database_url:Some("sqlite://./data/products.db".to_string()),use_api:true,cache_duration_secs:300,search_enabled:true,max_results:100,}}}#[cfg_attr(not(target_arch="wasm32"),async_trait)]#[cfg_attr(target_arch="wasm32",async_trait(?Send))]trait ProductDataSource:Send +Sync +std::fmt::Debug{async fn get_products(&self,limit:Option<usize>,offset:Option<usize>)->Result<Vec<Product>>;async fn get_product(&self,id:&str)->Result<Option<Product>>;async fn search_products(&self,query:&str,limit:Option<usize>)->Result<Vec<Product>>;async fn get_categories(&self)->Result<Vec<String>>;}#[derive(Debug)]struct MockDataSource;impl MockDataSource{fn new()->Self{Self}}#[cfg_attr(not(target_arch="wasm32"),async_trait)]#[cfg_attr(target_arch="wasm32",async_trait(?Send))]impl ProductDataSource for MockDataSource{async fn get_products(&self,limit:Option<usize>,_offset:Option<usize>)->Result<Vec<Product>>{let products=vec![Product{id:"prod_001".to_string(),name:"Sample Product 1".to_string(),description:"A sample product for demonstration".to_string(),category:"Electronics".to_string(),price:299.99,currency:"USD".to_string(),stock_quantity:50,sku:"SAMPLE-001".to_string(),barcode:Some("1234567890123".to_string()),images:vec!["https://example.com/product1.jpg".to_string()],attributes:HashMap::new(),created_at:Time::now(),updated_at:Time::now(),is_active:true,},Product{id:"prod_002".to_string(),name:"Sample Product 2".to_string(),description:"Another sample product".to_string(),category:"Books".to_string(),price:19.99,currency:"USD".to_string(),stock_quantity:100,sku:"SAMPLE-002".to_string(),barcode:Some("1234567890124".to_string()),images:vec!["https://example.com/product2.jpg".to_string()],attributes:HashMap::new(),created_at:Time::now(),updated_at:Time::now(),is_active:true,},];let limited_products=if let Some(limit)=limit{products.into_iter().take(limit).collect()}else{products};Ok(limited_products)}async fn get_product(&self,id:&str)->Result<Option<Product>>{let products=self.get_products(None,None).await?;Ok(products.into_iter().find(|p|p.id==id))}async fn search_products(&self,query:&str,limit:Option<usize>)->Result<Vec<Product>>{let all_products=self.get_products(None,None).await?;let filtered:Vec<Product>=all_products.into_iter().filter(|p|{p.name.to_lowercase().contains(&query.to_lowercase())||p.description.to_lowercase().contains(&query.to_lowercase())||p.category.to_lowercase().contains(&query.to_lowercase())}).collect();let limited_products=if let Some(limit)=limit{filtered.into_iter().take(limit).collect()}else{filtered};Ok(limited_products)}async fn get_categories(&self)->Result<Vec<String>>{Ok(vec!["Electronics".to_string(),"Books".to_string(),"Clothing".to_string(),"Home & Garden".to_string(),])}}#[derive(Debug)]struct ApiDataSource{endpoint:String,timeout_secs:u64,}impl ApiDataSource{fn new(endpoint:String)->Self{Self{endpoint,timeout_secs:30,}}async fn make_request(&self,url:&str)->Result<serde_json::Value>{tracing::info!("Mock API request to: {}",url);Ok(serde_json::json!([{"id":"api_prod_001","name":"API Product 1","description":"Product from API","category":"API Category","price":99.99,"currency":"USD","stock_quantity":25,"sku":"API-001","barcode":"9876543210123","images":["https://api.example.com/product1.jpg"],"attributes":{},"created_at":"2024-01-01T00:00:00Z","updated_at":"2024-01-01T00:00:00Z","is_active":true}]))}}#[cfg_attr(not(target_arch="wasm32"),async_trait)]#[cfg_attr(target_arch="wasm32",async_trait(?Send))]impl ProductDataSource for ApiDataSource{async fn get_products(&self,limit:Option<usize>,offset:Option<usize>)->Result<Vec<Product>>{let mut url=format!("{}/products",self.endpoint);let mut params=Vec::new();if let Some(limit)=limit{params.push(format!("limit={}",limit));}if let Some(offset)=offset{params.push(format!("offset={}",offset));}if!params.is_empty(){url.push('?');url.push_str(&params.join("&"));}let json=self.make_request(&url).await?;let products:Vec<Product>=serde_json::from_value(json).map_err(|e|{Error::plugin("product_catalog",format!("Failed to parse products: {}",e))})?;Ok(products)}async fn get_product(&self,id:&str)->Result<Option<Product>>{let url=format!("{}/products/{}",self.endpoint,id);match self.make_request(&url).await{Ok(json)=>{let product:Product=serde_json::from_value(json).map_err(|e|{Error::plugin("product_catalog",format!("Failed to parse product: {}",e))})?;Ok(Some(product))}Err(e)=>{if e.to_string().contains("404"){Ok(None)}else{Err(e)}}}}async fn search_products(&self,query:&str,limit:Option<usize>)->Result<Vec<Product>>{let encoded_query=urlencoding::encode(query);let mut url=format!("{}/products/search?q={}",self.endpoint,encoded_query);if let Some(limit)=limit{url.push_str(&format!("&limit={}",limit));}let json=self.make_request(&url).await?;let products:Vec<Product>=serde_json::from_value(json).map_err(|e|{Error::plugin("product_catalog",format!("Failed to parse search results: {}",e))})?;Ok(products)}async fn get_categories(&self)->Result<Vec<String>>{let url=format!("{}/categories",self.endpoint);let json=self.make_request(&url).await?;let categories:Vec<String>=serde_json::from_value(json).map_err(|e|{Error::plugin("product_catalog",format!("Failed to parse categories: {}",e))})?;Ok(categories)}}pub struct ProductCatalogPlugin{config:PluginConfig,data_source:Option<Arc<dyn ProductDataSource>>,search_provider:Option<Arc<ProductSearchProvider>>,product_cache:Arc<RwLock<HashMap<String,(Product,DateTime<Utc>)>>>,context:Option<PluginContext>,}impl std::fmt::Debug for ProductCatalogPlugin{fn fmt(&self,f:&mut std::fmt::Formatter<'_>)->std::fmt::Result{f.debug_struct("ProductCatalogPlugin").field("config",&self.config).finish()}}impl ProductCatalogPlugin{pub fn new()->Self{Self{config:PluginConfig::default(),data_source:None,search_provider:None,product_cache:Arc::new(RwLock::new(HashMap::new())),context:None,}}async fn initialize_data_source(&mut self,context:&PluginContext)->Result<()>{if let Ok(Some(config_value))=context.api_client.get_config("product_catalog").await{if let Ok(config)=serde_json::from_value::<PluginConfig>(config_value){self.config=config;}}let data_source:Arc<dyn ProductDataSource>=if self.config.use_api{if let Some(ref endpoint)=self.config.api_endpoint{tracing::info!("Using API data source: {}",endpoint);Arc::new(ApiDataSource::new(endpoint.clone()))}else{tracing::warn!("API endpoint not configured, falling back to mock data source");Arc::new(MockDataSource::new())}}else{tracing::info!("Database mode requested, but using mock data source for demo");Arc::new(MockDataSource::new())};self.data_source=Some(data_source.clone());if self.config.search_enabled{self.search_provider=Some(Arc::new(ProductSearchProvider{data_source:data_source.clone(),config:self.config.clone(),}));}Ok(())}async fn get_cached_product(&self,id:&str)->Option<Product>{let cache=self.product_cache.read().await;if let Some((product,cached_at))=cache.get(id){let age=Time::now().signed_duration_since(*cached_at);if age.num_seconds()<self.config.cache_duration_secs as i64{return Some(product.clone());}}None}async fn cache_product(&self,product:Product){let mut cache=self.product_cache.write().await;cache.insert(product.id.clone(),(product,Time::now()));}}impl Default for ProductCatalogPlugin{fn default()->Self{Self::new()}}#[cfg_attr(not(target_arch="wasm32"),async_trait)]#[cfg_attr(target_arch="wasm32",async_trait(?Send))]impl Plugin for ProductCatalogPlugin{fn info(&self)->PluginInfo{PluginInfo{id:"product_catalog".to_string(),name:"Product Catalog".to_string(),version:"1.0.0".to_string(),description:"Product catalog management with search capabilities".to_string(),author:"Qorzen Team".to_string(),license:"MIT".to_string(),homepage:Some("https://github.com/qorzen/plugins/product-catalog".to_string()),repository:Some("https://github.com/qorzen/plugins".to_string()),minimum_core_version:"0.1.0".to_string(),supported_platforms:vec![Platform::All],}}fn required_dependencies(&self)->Vec<PluginDependency>{vec![]}fn required_permissions(&self)->Vec<Permission>{vec![Permission{resource:"products".to_string(),action:"read".to_string(),scope:PermissionScope::Global,},Permission{resource:"search".to_string(),action:"provide".to_string(),scope:PermissionScope::Global,},Permission{resource:"ui".to_string(),action:"rende__STRING_LITERAL_0__Initializing Product Catalog plugin");self.context=Some(context.clone());match self.initialize_data_source(&context).await{Ok(_)=>{tracing::info!("Product Catalog plugin initialized successfully");Ok(())}Err(e)=>{tracing::warn!("Data source initialization failed, using fallback: {}",e);self.data_source=Some(Arc::new(MockDataSource::new()));tracing::info!("Product Catalog plugin initialized with mock data source");Ok(())}}}async fn shutdown(&mut self)->Result<()>{tracing::info!("Shutting down Product Catalog plugin");Ok(())}fn ui_components(&self)->Vec<UIComponent>{vec![UIComponent{id:"product_list".to_string(),name:"Product List".to_string(),component_type:ComponentType::Page,props:serde_json::json!({"title":"Products","searchable":true}),required_permissions:vec![Permission{resource:"products".to_string(),action:"read".to_string(),scope:PermissionScope::Global,}],},UIComponent{id:"product_detail".to_string(),name:"Product Detail".to_string(),component_type:ComponentType::Page,props:serde_json::json!({"editable":false}),required_permissions:vec![Permission{resource:"products".to_string(),action:"read".to_string(),scope:PermissionScope::Global,}],},]}fn menu_items(&self)->Vec<MenuItem>{vec![MenuItem{id:"products".to_string(),label:"Products".to_string(),icon:Some("ðŸ“¦".to_string()),route:Some("/plugins/product_catalog/products".to_string()),action:None,required_permissions:vec![Permission{resource:"products".to_string(),action:"read".to_string(),scope:PermissionScope::Global,}],order:100,children:vec![MenuItem{id:"product_list".to_string(),label:"All Products".to_string(),icon:Some("ðŸ“‹".to_string()),route:Some("/plugins/product_catalog/products".to_string()),action:None,required_permissions:vec![],order:0,children:vec![],},MenuItem{id:"product_categories".to_string(),label:"Categories".to_string(),icon:Some("ðŸ·ï¸".to_string()),route:Some("/plugins/product_catalog/categories".to_string()),action:None,required_permissions:vec![],order:1,children:vec![],},],}]}fn settings_schema(&self)->Option<SettingsSchema>{Some(SettingsSchema{version:"1.0".to_string(),schema:serde_json::json!({"type":"object","properties":{"api_endpoint":{"type":"string","title":"API Endpoint","description":"URL for the product API"},"database_url":{"type":"string","title":"Database URL","description":"Database connection string"},"use_api":{"type":"boolean","title":"Use API","description":"Whether to use API or direct database access","default":true},"cache_duration_secs":{"type":"intege__STRING_LITERAL_1__title":"Cache Duration (seconds)","description":"How long to cache product data","default":300,"minimum":0},"search_enabled":{"type":"boolean","title":"Enable Search","description":"Enable search provider functionality","default":true},"max_results":{"type":"intege__STRING_LITERAL_2__title":"Max Results","description":"Maximum number of results to return","default":100,"minimum":1,"maximum":1000}}}),defaults:serde_json::to_value(PluginConfig::default()).unwrap_or_default(),})}fn api_routes(&self)->Vec<ApiRoute>{vec![ApiRoute{path:"/api/plugins/product_catalog/products".to_string(),method:HttpMethod::GET,handler_id:"list_products".to_string(),required_permissions:vec![Permission{resource:"products".to_string(),action:"read".to_string(),scope:PermissionScope::Global,}],rate_limit:Some(RateLimit{requests_per_minute:60,burst_limit:10,}),documentation:ApiDocumentation{summary:"List products".to_string(),description:"Get a list of products with optional pagination".to_string(),parameters:vec![ApiParameter{name:"limit".to_string(),parameter_type:ParameterType::Query,required:false,description:"Maximum number of products to return".to_string(),example:Some(serde_json::json!(10)),},ApiParameter{name:"offset".to_string(),parameter_type:ParameterType::Query,required:false,description:"Number of products to skip".to_string(),example:Some(serde_json::json!(0)),},],responses:vec![ApiResponse{status_code:200,description:"List of products".to_string(),schema:Some(serde_json::json!({"type":"array","items":{"type":"object","properties":{"id":{"type":"string"},"name":{"type":"string"},"price":{"type":"numbe__STRING_LITERAL_3__product.updated".to_string(),handler_id:"handle_product_update".to_string(),priority:100,}]}fn render_component(&self,component_id:&str,_props:serde_json::Value)->Result<dioxus::prelude::VNode>{use dioxus::prelude::*;match component_id{"product_list"=>{let node=rsx!{div{class:"product-list",h2{"Product Catalog"}p{"This is a placeholder for the product list component."}div{class:"notice","Component rendering would be implemented with actual product data in a real plugin."}}}.map_err(|e|Error::plugin("product_catalog",&e.to_string()))?;Ok(node)}"product_detail"=>{let node=rsx!{div{class:"product-detail",h2{"Product Details"}p{"This is a placeholder for the product detail component."}div{class:"notice","Component rendering would be implemented with actual product data in a real plugin."}}}.map_err(|e|Error::plugin("product_catalog",&e.to_string()))?;Ok(node)}_=>Err(Error::plugin("product_catalog","Unknown component")),}}async fn handle_api_request(&self,route_id:&str,request:ApiRequest)->Result<ApiResponse>{match route_id{"list_products"=>{if let Some(ref data_source)=self.data_source{let limit=request.query_params.get("limit").and_then(|s|s.parse().ok());let offset=request.query_params.get("offset").and_then(|s|s.parse().ok());let products=data_source.get_products(limit,offset).await?;Ok(ApiResponse{status_code:200,description:"Success".to_string(),schema:Some(serde_json::to_value(&products).map_err(|e|{Error::plugin("product_catalog",format!("Serialization failed: {}",e))})?),})}else{Err(Error::plugin("product_catalog","Data source not initialized"))}}_=>Err(Error::plugin("product_catalog","Unknown API route")),}}async fn handle_event(&self,handler_id:&str,event:&dyn Event)->Result<()>{match handler_id{"handle_product_update"=>{tracing::info!("Product updated: {}",event.event_type());Ok(())}_=>Err(Error::plugin("product_catalog","Unknown event handle__STRING_LITERAL_4__wasm32"),async_trait)]#[cfg_attr(target_arch="wasm32",async_trait(?Send))]impl SearchProvider for ProductSearchProvider{fn provider_id(&self)->&str{"product_catalog_search"}fn provider_name(&self)->&str{"Product Catalog Search"}fn description(&self)->&str{"Search products by name, description, and category"}fn priority(&self)->i32{200}fn supported_result_types(&self)->Vec<String>{vec!["product".to_string()]}fn supports_facets(&self)->bool{true}fn supports_suggestions(&self)->bool{true}async fn search(&self,query:&SearchQuery)->Result<Vec<SearchResult>>{let products=self.data_source.search_products(&query.query,query.limit).await?;let mut results=Vec::new();for product in products{let score=if product.name.to_lowercase().contains(&query.query.to_lowercase()){0.9}else if product.description.to_lowercase().contains(&query.query.to_lowercase()){0.7}else{0.5};results.push(SearchResult{id:product.id.clone(),result_type:"product".to_string(),title:product.name.clone(),description:Some(product.description.clone()),score,url:Some(format!("/plugins/product_catalog/products/{}",product.id)),thumbnail:product.images.first().cloned(),metadata:{let mut metadata=HashMap::new();metadata.insert("price".to_string(),serde_json::json!(product.price));metadata.insert("currency".to_string(),serde_json::json!(product.currency));metadata.insert("category".to_string(),serde_json::json!(product.category));metadata.insert("stock".to_string(),serde_json::json!(product.stock_quantity));metadata},source_plugin:"product_catalog".to_string(),timestamp:product.updated_at,});}Ok(results)}async fn get_facets(&self,_query:&SearchQuery)->Result<Vec<SearchFacet>>{let categories=self.data_source.get_categories().await?;let category_facet=SearchFacet{field:"category".to_string(),name:"Category".to_string(),values:categories
.into_iter().map(|cat|FacetValue{value:serde_json::Value::String(cat.clone()),display_name:cat,count:0,}).collect(),};Ok(vec![category_facet])}async fn get_suggestions(&self,query:&SearchQuery)->Result<Vec<SearchSuggestion>>{let products=self.data_source.search_products(&query.query,Some(5)).await?;let suggestions=products.into_iter().map(|product|SearchSuggestion{text:query.query.clone(),completion:product.name,category:Some("Products".to_string()),score:0.8,}).collect();Ok(suggestions)}async fn health_check(&self)->Result<ProviderHealth>{let start=std::time::Instant::now();match self.data_source.get_products(Some(1),None).await{Ok(_)=>Ok(ProviderHealth{is_healthy:true,response_time_ms:Some(start.elapsed().as_millis()as u64),error_message:None,last_check:Time::now(),}),Err(e)=>Ok(ProviderHealth{is_healthy:false,response_time_ms:Some(start.elapsed().as_millis()as u64),error_message:Some(e.to_string()),last_check:Time::now(),}),}}}#[macro_use]extern crate qorzen_oxide;export_plugin!(ProductCatalogPlugin);#[cfg(test)]mod tests{use super::*;#[tokio::test]async fn test_plugin_info(){let plugin=ProductCatalogPlugin::new();let info=plugin.info();assert_eq!(info.id,"product_catalog");assert_eq!(info.name,"Product Catalog");assert!(!info.supported_platforms.is_empty());}#[test]fn test_plugin_permissions(){let plugin=ProductCatalogPlugin::new();let permissions=plugin.required_permissions();assert!(!permissions.is_empty());assert!(permissions
.iter().any(|p|p.resource=="products"&&p.action=="read"));}#[test]fn test_config_defaults(){let config=PluginConfig::default();assert_eq!(config.use_api,true);assert_eq!(config.cache_duration_secs,300);assert!(config.search_enabled);assert_eq!(config.max_results,100);}#[tokio::test]async fn test_mock_data_source(){let data_source=MockDataSource::new();let products=data_source.get_products(Some(10),None).await.unwrap();assert!(!products.is_empty());assert_eq!(products[0].id,"prod_001");let product=data_source.get_product("prod_001").await.unwrap();assert!(product.is_some());let missing=data_source.get_product("nonexistent").await.unwrap();assert!(missing.is_none());let search_results=data_source.search_products("sample",None).await.unwrap();assert!(!search_results.is_empty());let categories=data_source.get_categories().await.unwrap();assert!(categories.contains(&"Electronics".to_string()));}#[tokio::test]async fn test_plugin_lifecycle(){let mut plugin=ProductCatalogPlugin::new();let info=plugin.info();assert_eq!(info.id,"product_catalog");let components=plugin.ui_components();assert!(!components.is_empty());assert!(components.iter().any(|c|c.id=="product_list"));let menu_items=plugin.menu_items();assert!(!menu_items.is_empty());assert!(menu_items.iter().any(|m|m.id=="products"));let schema=plugin.settings_schema();assert!(schema.is_some());}}
