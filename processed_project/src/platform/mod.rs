use async_trait::async_trait;use serde::{Deserialize,Serialize};use std::collections::HashMap;use std::sync::Arc;use tokio::sync::RwLock;use uuid::Uuid;use crate::error::Result;use crate::manager::{ManagedState,Manager,ManagerStatus,PlatformRequirements};#[cfg(not(target_arch="wasm32"))]pub mod native;#[cfg(target_arch="wasm32")]pub mod web;pub mod database;pub mod filesystem;pub mod network;pub mod storage;use crate::platform::database::DatabaseArc;use crate::platform::filesystem::FileSystemArc;use crate::platform::network::NetworkArc;use crate::platform::storage::StorageArc;use crate::Error;pub use database::{DatabaseProvider,Migration,QueryResult,Row,Transaction};pub use filesystem::{FileInfo,FileMetadata,FileSystemProvider};pub use network::{NetworkProvider,NetworkRequest,NetworkResponse};pub use storage::StorageProvider;#[derive(Debug,Clone,Serialize,Deserialize)]pub struct PlatformCapabilities{pub has_filesystem:bool,pub has_database:bool,pub has_background_tasks:bool,pub has_push_notifications:bool,pub has_biometric_auth:bool,pub has_camera:bool,pub has_location:bool,pub max_file_size:Option<u64>,pub supported_formats:Vec<String>,pub platform_name:String,pub platform_version:String,}impl Default for PlatformCapabilities{fn default()->Self{Self{has_filesystem:false,has_database:false,has_background_tasks:false,has_push_notifications:false,has_biometric_auth:false,has_camera:false,has_location:false,max_file_size:None,supported_formats:Vec::new(),platform_name:"unknown".to_string(),platform_version:"unknown".to_string(),}}}pub struct PlatformManager{state:ManagedState,filesystem:FileSystemArc,database:DatabaseArc,network:NetworkArc,storage:StorageArc,capabilities:PlatformCapabilities,}impl std::fmt::Debug for PlatformManager{fn fmt(&self,f:&mut std::fmt::Formatter<'_>)->std::fmt::Result{f.debug_struct("PlatformManage__STRING_LITERAL_0__capabilities",&self.capabilities).finish()}}impl PlatformManager{pub fn new()->Result<Self>{let capabilities=Self::detect_capabilities();#[cfg(not(target_arch="wasm32"))]let providers=native::create_providers()?;#[cfg(target_arch="wasm32")]let providers=web::create_providers()?;Ok(Self{state:ManagedState::new(Uuid::new_v4(),"platform_manage__STRING_LITERAL_1__wasm32"))]return native::detect_capabilities();#[cfg(target_arch="wasm32")]return web::detect_capabilities();}pub fn capabilities(&self)->&PlatformCapabilities{&self.capabilities}pub fn filesystem(&self)->&dyn FileSystemProvider{self.filesystem.as_ref()}pub fn filesystem_arc(&self)->FileSystemArc{Arc::clone(&self.filesystem)}pub fn database(&self)->&dyn DatabaseProvider{self.database.as_ref()}pub fn database_arc(&self)->DatabaseArc{Arc::clone(&self.database)}pub fn network(&self)->&dyn NetworkProvider{self.network.as_ref()}pub fn storage(&self)->&dyn StorageProvider{self.storage.as_ref()}}#[cfg(not(target_arch="wasm32"))]#[async_trait]impl Manager for PlatformManager{fn name(&self)->&str{"platform_manage__STRING_LITERAL_2__wasm32"))]native::initialize().await?;#[cfg(target_arch="wasm32")]web::initialize().await?;self.state.set_state(crate::manager::ManagerState::Running).await;Ok(())}async fn shutdown(&mut self)->Result<()>{self.state
.set_state(crate::manager::ManagerState::ShuttingDown).await;#[cfg(not(target_arch="wasm32"))]native::cleanup().await?;#[cfg(target_arch="wasm32")]web::cleanup().await?;self.state
.set_state(crate::manager::ManagerState::Shutdown).await;Ok(())}async fn status(&self)->ManagerStatus{let mut status=self.state.status().await;status.add_metadata("platform",serde_json::json!(self.capabilities.platform_name),);status.add_metadata("capabilities",serde_json::to_value(&self.capabilities).unwrap_or_default(),);status}fn platform_requirements(&self)->PlatformRequirements{PlatformRequirements{requires_filesystem:true,requires_network:true,requires_database:true,requires_native_apis:false,minimum_permissions:vec!["platform.access".to_string()],}}}#[cfg(target_arch="wasm32")]#[async_trait(?Send)]impl Manager for PlatformManager{fn name(&self)->&str{"platform_manage__STRING_LITERAL_3__wasm32"))]native::initialize().await?;#[cfg(target_arch="wasm32")]web::initialize().await?;self.state.set_state(crate::manager::ManagerState::Running).await;Ok(())}async fn shutdown(&mut self)->Result<()>{self.state
.set_state(crate::manager::ManagerState::ShuttingDown).await;#[cfg(not(target_arch="wasm32"))]native::cleanup().await?;#[cfg(target_arch="wasm32")]web::cleanup().await?;self.state
.set_state(crate::manager::ManagerState::Shutdown).await;Ok(())}async fn status(&self)->ManagerStatus{let mut status=self.state.status().await;status.add_metadata("platform",serde_json::json!(self.capabilities.platform_name),);status.add_metadata("capabilities",serde_json::to_value(&self.capabilities).unwrap_or_default(),);status}fn platform_requirements(&self)->PlatformRequirements{PlatformRequirements{requires_filesystem:true,requires_network:true,requires_database:true,requires_native_apis:false,minimum_permissions:vec!["platform.access".to_string()],}}}pub struct PlatformProviders{pub filesystem:FileSystemArc,pub database:DatabaseArc,pub network:NetworkArc,pub storage:StorageArc,}#[derive(Debug,Default)]pub struct MockFileSystem{files:Arc<RwLock<HashMap<String,Vec<u8>>>>,}impl MockFileSystem{pub fn new()->Self{Self{files:Arc::new(RwLock::new(HashMap::new())),}}}impl filesystem::FileSystemBounds for MockFileSystem{}#[cfg_attr(not(target_arch="wasm32"),async_trait)]#[cfg_attr(target_arch="wasm32",async_trait(?Send))]impl FileSystemProvider for MockFileSystem{async fn read_file(&self,path:&str)->Result<Vec<u8>>{self.files.read().await.get(path).cloned().ok_or_else(||Error::platform("mock","filesystem","File not found"))}async fn write_file(&self,path:&str,data:&[u8])->Result<()>{self.files
.write().await
.insert(path.to_string(),data.to_vec());Ok(())}async fn delete_file(&self,path:&str)->Result<()>{self.files.write().await.remove(path);Ok(())}async fn list_directory(&self,_path:&str)->Result<Vec<FileInfo>>{Ok(Vec::new())}async fn create_directory(&self,_path:&str)->Result<()>{Ok(())}async fn file_exists(&self,path:&str)->bool{self.files.read().await.contains_key(path)}async fn get_metadata(&self,_path:&str)->Result<FileMetadata>{Ok(FileMetadata{size:0,is_directory:false,is_readonly:false,created:None,modified:chrono::Utc::now(),accessed:None,})}}
