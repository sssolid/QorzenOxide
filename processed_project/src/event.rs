use std::any::Any;use std::collections::HashMap;use std::fmt::{self,Debug};use std::sync::atomic::{AtomicU64,Ordering};use std::sync::Arc;use std::time::{Duration,Instant};use crate::utils::Time;use async_trait::async_trait;use chrono::{DateTime,Utc};use dashmap::DashMap;use serde::{Deserialize,Serialize};use tokio::sync::{mpsc,RwLock};use uuid::Uuid;use crate::error::{Error,ErrorKind,EventOperation,Result};use crate::manager::{ManagedState,Manager,ManagerStatus};use crate::types::Metadata;pub trait Event:Send +Sync +Debug{fn event_type(&self)->&'static str;fn source(&self)->&str;fn metadata(&self)->&Metadata;fn as_any(&self)->&dyn Any;fn timestamp(&self)->DateTime<Utc>{Time::now()}fn correlation_id(&self)->Option<Uuid>{self.metadata().get("correlation_id").and_then(|v|v.as_str()).and_then(|s|Uuid::parse_str(s).ok())}fn priority(&self)->EventPriority{EventPriority::Normal}fn should_persist(&self)->bool{false}}#[derive(Debug,Clone,Copy,PartialEq,Eq,PartialOrd,Ord,Hash,Serialize,Deserialize)]pub enum EventPriority{Low=0,Normal=50,High=100,Critical=200,}impl Default for EventPriority{fn default()->Self{Self::Normal}}#[cfg(not(target_arch="wasm32"))]#[async_trait]pub trait EventHandler:Send +Sync +Debug{async fn handle(&self,event:&dyn Event)->Result<()>;fn name(&self)->&str;fn event_types(&self)->Vec<&'static str>;fn is_wildcard(&self)->bool{false}fn priority(&self)->i32{0}}#[cfg(target_arch="wasm32")]#[async_trait(?Send)]pub trait EventHandler:Debug{async fn handle(&self,event:&dyn Event)->Result<()>;fn name(&self)->&str;fn event_types(&self)->Vec<&'static str>;fn is_wildcard(&self)->bool{false}fn priority(&self)->i32{0}}#[derive(Debug,Clone)]pub struct EventFilter{pub event_types:Vec<String>,pub source_patterns:Vec<String>,pub metadata_filters:HashMap<String,serde_json::Value>,pub min_priority:EventPriority,}impl EventFilter{pub fn new()->Self{Self{event_types:Vec::new(),source_patterns:Vec::new(),metadata_filters:HashMap::new(),min_priority:EventPriority::Low,}}pub fn with_event_type(mut self,event_type:impl Into<String>)->Self{self.event_types.push(event_type.into());self}pub fn with_source_pattern(mut self,pattern:impl Into<String>)->Self{self.source_patterns.push(pattern.into());self}pub fn with_metadata(mut self,key:impl Into<String>,value:serde_json::Value)->Self{self.metadata_filters.insert(key.into(),value);self}pub fn with_min_priority(mut self,priority:EventPriority)->Self{self.min_priority=priority;self}pub fn matches(&self,event:&dyn Event)->bool{if!self.event_types.is_empty()&&!self.event_types.contains(&event.event_type().to_string()){return false;}if!self.source_patterns.is_empty(){let source=event.source();if!self.source_patterns.iter().any(|pattern|{pattern=="*"||source.contains(pattern)}){return false;}}if event.priority()<self.min_priority{return false;}let event_metadata=event.metadata();for(key,expected_value)in&self.metadata_filters{match event_metadata.get(key){Some(actual_value)=>{if actual_value!=expected_value{return false;}}None=>return false,}}true}}impl Default for EventFilter{fn default()->Self{Self::new()}}pub type EventRef=Arc<dyn Event>;pub struct EventSubscription{pub id:Uuid,pub filter:EventFilter,pub sender:mpsc::UnboundedSender<EventRef>,pub created_at:DateTime<Utc>,pub active:bool,pub metadata:Metadata,}impl Debug for EventSubscription{fn fmt(&self,f:&mut fmt::Formatter<'_>)->fmt::Result{f.debug_struct("EventSubscription").field("id",&self.id).field("filte__STRING_LITERAL_0__created_at",&self.created_at).field("active",&self.active).field("metadata",&self.metadata).finish()}}#[derive(Debug,Clone,Serialize,Deserialize)]pub struct EventStats{pub total_published:u64,pub total_processed:u64,pub total_failed:u64,pub events_by_type:HashMap<String,u64>,pub events_by_priority:HashMap<EventPriority,u64>,pub avg_processing_time_ms:f64,pub active_subscriptions:usize,pub queue_size:usize,}#[derive(Debug,Clone)]pub struct EventBusConfig{pub worker_count:usize,pub queue_capacity:usize,pub default_timeout:Duration,pub enable_persistence:bool,pub enable_metrics:bool,pub batch_size:usize,pub max_retry_delay:Duration,}fn get_default_worker_count()->usize{#[cfg(not(target_arch="wasm32"))]{num_cpus::get()}#[cfg(target_arch="wasm32")]{1}}impl Default for EventBusConfig{fn default()->Self{Self{worker_count:get_default_worker_count(),queue_capacity:10000,default_timeout:Duration::from_secs(30),enable_persistence:false,enable_metrics:true,batch_size:100,max_retry_delay:Duration::from_secs(60),}}}#[derive(Debug)]struct EventEnvelope{event:EventRef,#[allow(dead_code)]received_at:Instant,#[allow(dead_code)]retry_count:u32,#[allow(dead_code)]max_retries:u32,}#[cfg(not(target_arch="wasm32"))]type WorkerHandle=tokio::task::JoinHandle<()>;#[cfg(target_arch="wasm32")]type WorkerHandle=();pub struct EventBusManager{state:ManagedState,config:EventBusConfig,subscriptions:Arc<DashMap<Uuid,EventSubscription>>,event_queue:mpsc::UnboundedSender<EventEnvelope>,stats:Arc<RwLock<EventStats>>,event_counter:Arc<AtomicU64>,worker_handles:Vec<WorkerHandle>,}impl Debug for EventBusManager{fn fmt(&self,f:&mut fmt::Formatter<'_>)->fmt::Result{f.debug_struct("EventBusManage__STRING_LITERAL_1__config",&self.config).field("subscriptions",&self.subscriptions.len()).finish()}}impl EventBusManager{pub fn new(config:EventBusConfig)->Self{let(event_sender,_event_receiver)=mpsc::unbounded_channel::<EventEnvelope>();Self{state:ManagedState::new(Uuid::new_v4(),"event_bus_manage__STRING_LITERAL_2__unknown".to_string()),subscriber_id:None,operation:EventOperation::Publish,},"Event queue is closed",)})?;Ok(())}pub async fn subscribe(&self,filter:EventFilter,)->Result<mpsc::UnboundedReceiver<EventRef>>{let(sender,receiver)=mpsc::unbounded_channel::<EventRef>();let subscription_id=Uuid::new_v4();let subscription=EventSubscription{id:subscription_id,filter,sender,created_at:Time::now(),active:true,metadata:HashMap::new(),};self.subscriptions.insert(subscription_id,subscription);{let mut stats=self.stats.write().await;stats.active_subscriptions=self.subscriptions.len();}tracing::debug!("Created subscription: {}",subscription_id);Ok(receiver)}#[cfg(not(target_arch="wasm32"))]pub async fn subscribe_with_handler<H>(&self,filter:EventFilter,handler:Arc<H>,)->Result<Uuid>whereH:EventHandler +'static +Send +Sync,{let mut receiver=self.subscribe(filter).await?;let handler_name=handler.name().to_string();let handle=tokio::spawn(async move{while let Some(event)=receiver.recv().await{let start_time=Instant::now();match handler.handle(event.as_ref()).await{Ok(())=>{let processing_time=start_time.elapsed();tracing::trace!("Handler '{}' processed event in {:?}",handler_name,processing_time);}Err(e)=>{tracing::error!("Handler '{}' failed to process event: {}",handler_name,e);}}}});drop(handle);Ok(Uuid::new_v4())}#[cfg(target_arch="wasm32")]pub async fn subscribe_with_handler<H>(&self,filter:EventFilter,handler:Arc<H>,)->Result<Uuid>where
H:EventHandler +'static,{let mut receiver=self.subscribe(filter).await?;let handler_name=handler.name().to_string();wasm_bindgen_futures::spawn_local(async move{while let Some(event)=receiver.recv().await{let start_time=Instant::now();match handler.handle(event.as_ref()).await{Ok(())=>{let processing_time=start_time.elapsed();web_sys::console::log_1(&format!("Handler '{}' processed event in {:?}",handler_name,processing_time).into(),);}Err(e)=>{web_sys::console::error_1(&format!("Handler '{}' failed to process event: {}",handler_name,e).into(),);}}}});Ok(Uuid::new_v4())}pub async fn unsubscribe(&self,subscription_id:Uuid)->Result<()>{if let Some(mut subscription)=self.subscriptions.get_mut(&subscription_id){subscription.active=false;}self.subscriptions.remove(&subscription_id).ok_or_else(||{Error::new(ErrorKind::Event{event_type:None,subscriber_id:Some(subscription_id),operation:EventOperation::Subscribe,},"Subscription not found",)})?;{let mut stats=self.stats.write().await;stats.active_subscriptions=self.subscriptions.len();}tracing::debug!("Removed subscription: {}",subscription_id);Ok(())}pub async fn get_stats(&self)->EventStats{self.stats.read().await.clone()}#[cfg(not(target_arch="wasm32"))]async fn start_workers(&mut self)->Result<()>{let(event_sender,event_receiver)=mpsc::unbounded_channel::<EventEnvelope>();self.event_queue=event_sender;let subscriptions=Arc::clone(&self.subscriptions);let stats=Arc::clone(&self.stats);let handle=tokio::spawn(Self::worker_task(event_receiver,subscriptions,stats));self.worker_handles.push(handle);Ok(())}#[cfg(target_arch="wasm32")]async fn start_workers(&mut self)->Result<()>{let(event_sender,event_receiver)=mpsc::unbounded_channel::<EventEnvelope>();self.event_queue=event_sender;let subscriptions=Arc::clone(&self.subscriptions);let stats=Arc::clone(&self.stats);wasm_bindgen_futures::spawn_local(Self::worker_task(event_receiver,subscriptions,stats));self.worker_handles.push(());Ok(())}async fn worker_task(mut event_receiver:mpsc::UnboundedReceiver<EventEnvelope>,subscriptions:Arc<DashMap<Uuid,EventSubscription>>,stats:Arc<RwLock<EventStats>>,){#[cfg(not(target_arch="wasm32"))]tracing::debug!("Event worker started");#[cfg(target_arch="wasm32")]web_sys::console::log_1(&"Event worker started".into());while let Some(envelope)=event_receiver.recv().await{Self::process_event(envelope,&subscriptions,&stats).await;}#[cfg(not(target_arch="wasm32"))]tracing::debug!("Event worker stopped");#[cfg(target_arch="wasm32")]web_sys::console::log_1(&"Event worker stopped".into());}async fn process_event(envelope:EventEnvelope,subscriptions:&DashMap<Uuid,EventSubscription>,stats:&RwLock<EventStats>,){let start_time=Instant::now();let event=&envelope.event;let matching_subscriptions:Vec<(Uuid,EventRef)>=subscriptions.iter().filter_map(|entry|{let subscription=entry.value();if subscription.active&&subscription.filter.matches(event.as_ref()){Some((subscription.id,Arc::clone(event)))}else{None}}).collect();let mut successful_deliveries=0;let mut failed_deliveries=0;for(subscription_id,_event_clone)in matching_subscriptions{if let Some(subscription)=subscriptions.get(&subscription_id){match subscription.sender.send(Arc::clone(event)){Ok(())=>successful_deliveries +=1,Err(_)=>{failed_deliveries +=1;#[cfg(not(target_arch="wasm32"))]tracing::warn!("Failed to deliver event to subscription {}",subscription_id);#[cfg(target_arch="wasm32")]web_sys::console::warn_1(&format!("Failed to deliver event to subscription {}",subscription_id).into(),);}}}}let processing_time=start_time.elapsed();{let mut stats_guard=stats.write().await;stats_guard.total_processed +=1;if failed_deliveries>0{stats_guard.total_failed +=1;}let total_processed=stats_guard.total_processed;stats_guard.avg_processing_time_ms=(stats_guard.avg_processing_time_ms*(total_processed -1)as f64 +processing_time.as_millis()as f64)/total_processed as f64;}#[cfg(not(target_arch="wasm32"))]tracing::trace!("Processed event '{}' in {:?} (delivered to {} subscriptions, {} failed)",event.event_type(),processing_time,successful_deliveries,failed_deliveries);#[cfg(target_arch="wasm32")]web_sys::console::log_1(&format!("Processed event '{}' in {:?} (delivered to {} subscriptions, {} failed)",event.event_type(),processing_time,successful_deliveries,failed_deliveries).into(),);}#[cfg(not(target_arch="wasm32"))]async fn stop_workers(&mut self){for handle in self.worker_handles.drain(..){handle.abort();let _=handle.await;}}#[cfg(target_arch="wasm32")]async fn stop_workers(&mut self){self.worker_handles.clear();}}#[cfg(not(target_arch="wasm32"))]#[async_trait]impl Manager for EventBusManager{fn name(&self)->&str{"event_bus_manage__STRING_LITERAL_3__Event bus manager initialized with {} workers",self.config.worker_count);Ok(())}async fn shutdown(&mut self)->Result<()>{self.state
.set_state(crate::manager::ManagerState::ShuttingDown).await;self.stop_workers().await;self.subscriptions.clear();self.state
.set_state(crate::manager::ManagerState::Shutdown).await;tracing::info!("Event bus manager shut down");Ok(())}async fn status(&self)->ManagerStatus{let mut status=self.state.status().await;let stats=self.get_stats().await;status.add_metadata("total_published",serde_json::Value::from(stats.total_published),);status.add_metadata("total_processed",serde_json::Value::from(stats.total_processed),);status.add_metadata("total_failed",serde_json::Value::from(stats.total_failed));status.add_metadata("active_subscriptions",serde_json::Value::from(stats.active_subscriptions),);status.add_metadata("worker_count",serde_json::Value::from(self.config.worker_count),);status.add_metadata("avg_processing_time_ms",serde_json::Value::from(stats.avg_processing_time_ms),);status}}#[cfg(target_arch="wasm32")]#[async_trait(?Send)]impl Manager for EventBusManager{fn name(&self)->&str{"event_bus_manage__STRING_LITERAL_4__Event bus manager initialized with {} workers",self.config.worker_count).into(),);Ok(())}async fn shutdown(&mut self)->Result<()>{self.state.set_state(crate::manager::ManagerState::ShuttingDown).await;self.stop_workers().await;self.subscriptions.clear();self.state.set_state(crate::manager::ManagerState::Shutdown).await;web_sys::console::log_1(&"Event bus manager shut down".into());Ok(())}async fn status(&self)->ManagerStatus{let mut status=self.state.status().await;let stats=self.get_stats().await;status.add_metadata("total_published",serde_json::Value::from(stats.total_published),);status.add_metadata("total_processed",serde_json::Value::from(stats.total_processed),);status.add_metadata("total_failed",serde_json::Value::from(stats.total_failed));status.add_metadata("active_subscriptions",serde_json::Value::from(stats.active_subscriptions),);status.add_metadata("worker_count",serde_json::Value::from(self.config.worker_count),);status.add_metadata("avg_processing_time_ms",serde_json::Value::from(stats.avg_processing_time_ms),);status}}#[macro_export]macro_rules!define_event{($name:ident,$event_type:expr,$($field:ident:$type:ty),*)=>{#[derive(Debug,Clone,serde::Serialize,serde::Deserialize)]pub struct $name{pub timestamp:chrono::DateTime<chrono::Utc>,pub source:String,pub metadata:std::collections::HashMap<String,serde_json::Value>,$(pub $field:$type,)*}impl $crate::event::Event for $name{fn event_type(&self)->&'static str{$event_type}fn source(&self)->&str{&self.source}fn metadata(&self)->&$crate::types::Metadata{&self.metadata}fn as_any(&self)->&dyn std::any::Any{self}fn timestamp(&self)->chrono::DateTime<chrono::Utc>{self.timestamp}}};}#[cfg(test)]mod tests{use super::*;use std::time::Duration;#[derive(Debug,Clone)]struct TestEvent{source:String,metadata:Metadata,data:String,}impl Event for TestEvent{fn event_type(&self)->&'static str{"test.event"}fn source(&self)->&str{&self.source}fn metadata(&self)->&Metadata{&self.metadata}fn as_any(&self)->&dyn Any{self}}#[tokio::test]async fn test_event_bus_creation(){let config=EventBusConfig::default();let bus=EventBusManager::new(config);assert_eq!(bus.subscriptions.len(),0);}#[tokio::test]async fn test_event_publishing(){let config=EventBusConfig::default();let mut bus=EventBusManager::new(config);bus.initialize().await.unwrap();let event=TestEvent{source:"test".to_string(),metadata:HashMap::new(),data:"test data".to_string(),};bus.publish(event).await.unwrap();let stats=bus.get_stats().await;assert_eq!(stats.total_published,1);bus.shutdown().await.unwrap();}#[tokio::test]async fn test_event_subscription(){let config=EventBusConfig::default();let mut bus=EventBusManager::new(config);bus.initialize().await.unwrap();let filter=EventFilter::new().with_event_type("test.event");let mut receiver=bus.subscribe(filter).await.unwrap();let event=TestEvent{source:"test".to_string(),metadata:HashMap::new(),data:"test data".to_string(),};bus.publish(event).await.unwrap();tokio::time::sleep(Duration::from_millis(100)).await;if let Ok(received_event)=tokio::time::timeout(Duration::from_millis(100),receiver.recv()).await{assert!(received_event.is_some());let event=received_event.unwrap();assert_eq!(event.event_type(),"test.event");}bus.shutdown().await.unwrap();}#[test]fn test_event_filter(){let filter=EventFilter::new().with_event_type("test.event").with_source_pattern("test").with_min_priority(EventPriority::Normal);let event=TestEvent{source:"test_source".to_string(),metadata:HashMap::new(),data:"test data".to_string(),};assert!(filter.matches(&event));let filter_no_match=EventFilter::new().with_event_type("other.event");assert!(!filter_no_match.matches(&event));}#[test]fn test_event_priority(){assert!(EventPriority::Critical>EventPriority::High);assert!(EventPriority::High>EventPriority::Normal);assert!(EventPriority::Normal>EventPriority::Low);}}
